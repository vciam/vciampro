# Blueprint & Technical Guide: System State Synthesis & Recovery

**TASK ID:** DOC-SYN-001
**STATUS:** COMPLETE & EVOLVED

---

### **1. Directive Overview & Agent Persona Configuration**

#### **1.1. Primary Objective**
This document is a comprehensive technical guide and architectural blueprint, with all content synthesized directly and exclusively from the current state of the source code.

#### **1.2. Required Persona**
This document was generated by an expert AI Software Architect specializing in Context Engineering and Codebase Synthesis. All analysis and output adhere to KISS (Keep It Simple, Stupid) and RSOP (Reasonable Suite of Practices) principles.

#### **1.3. Deliverable Purpose**
This document serves as the official Single Source of Truth (SSOT). It is the definitive onboarding guide for human developers and the foundational context for all future refactoring and evolution tasks.

---

### **2. Technical Documentation & System Context**

#### **2.1. Project Synopsis**
The project is an AI-powered co-creative tool designed to evolve a user's raw text content by applying semantic context. Users provide this context through a system of predefined tags and a curated list of high-priority, user-defined keywords ("Reinforced Intentions").

**Key Features:**
*   **Content Input:** Text can be provided via direct entry, uploading a text file, or loaded from an auto-saved draft stored in the browser's local storage.
*   **Multi-layered Context Engineering:** Users guide the AI by selecting from predefined tags and adding custom keywords. The importance of these keywords can be increased ("Intent Intensity") to give them more weight in the AI's analysis.
*   **AI-driven Content Evolution:** The application uses Google Gemini models to rewrite and improve the user's content based on the provided context. A "Thinking Mode" is available, which leverages the more powerful `gemini-2.5-pro` model for deeper analysis of complex documents.
*   **Interactive Results:** The evolved content is displayed with features for copying, downloading as a Markdown file, and translation. Users can also select text from the output to create new reinforced keywords or form analysis groups.
*   **Context Persistence & Discovery:** The user's curated context (tags and keywords) can be exported to and imported from a JSON file. The import process includes an AI-powered "discovery engine" that analyzes the imported content to suggest new, relevant keywords to the user.
*   **Iterative Refinement:** After an initial generation, users can provide further instructions to the AI to refine the evolved content in a conversational loop.

#### **2.2. Core Technology Stack**

| Category       | Technology        | Version    | Notes / Key Libraries                                  |
|----------------|-------------------|------------|--------------------------------------------------------|
| Language       | TypeScript        | `~5.2.2`   | Statically typed language for robust code.             |
| Runtime        | Node.js / Browser | `18+`      | Required for the Vite development environment.           |
| UI Library     | React             | `^19.2.0`  | For building the user interface.                       |
| Build Tool     | Vite              | `^5.3.1`   | High-performance dev server and production bundler.    |
| Styling        | TailwindCSS       | `^3.4.4`   | Utility-first CSS framework.                           |
| State Mgt.     | React Hooks       | N/A        | `useState` and custom hooks for local/component state. |
| API Layer      | `@google/genai`   | `^1.27.0`  | Official SDK for Google Gemini API calls.              |
| Persistence    | `localStorage`    | N/A        | Browser API for auto-saving drafts.                    |
| **Testing**    | **N/A**           | **N/A**    | **No testing frameworks are currently present.**       |

#### **2.3. Local Development Environment Setup**
**Prerequisites:**
1.  Node.js (v18+ recommended)
2.  `pnpm` package manager (or `npm`/`yarn`)

**Installation Steps:**
```bash
# 1. Clone the repository
git clone https://github.com/chakssp/vciampro.git
cd vciampro

# 2. Install project dependencies
pnpm install

# 3. Create a local environment file by copying the example
cp .env.example .env.local

# 4. Configure your API Key
# Open the new .env.local file and add your Google Gemini API key.
```

**Environment Configuration:**
*   `VITE_API_KEY`: The Google Gemini API key. This is a hard requirement and must be placed in the `.env.local` file at the project root.

#### **2.4. Key Scripts & Commands**
All commands are run from the project root.

*   `pnpm dev`: Starts the Vite development server.
*   `pnpm build`: Bundles the application for production.
*   `pnpm preview`: Serves the production build locally.
*   `pnpm lint`: Performs a static type-check of the codebase.

#### **2.5. Architectural Map**
The project structure now includes configuration for the Vite build system.

```
/
├── .env.example            # Example environment file
├── .gitignore              # Files and directories ignored by Git
├── index.html              # Main HTML entry point for Vite
├── index.css               # Global stylesheet with Tailwind directives
├── package.json            # Project dependencies and scripts
├── vite.config.ts          # Vite configuration
├── tailwind.config.js      # TailwindCSS configuration
├── postcss.config.js       # PostCSS configuration
├── tsconfig.json           # Main TypeScript configuration
├── tsconfig.node.json      # TypeScript configuration for Node scripts
├── App.tsx                 # **MONOLITHIC** root component
├── index.tsx               # Renders the root React component
├── README.md               # Project Readme
├── metadata.json           # Application metadata
├── constants.ts
├── types.ts
├── /components/
├── /services/
└── /docs/
    ├── SYSTEM_BLUEPRINT.md # **THIS FILE**
    ├── blueprint.html
    └── blueprint-instruction-development.md
```

---

### **3. Architectural Analysis & Strategic Planning**

#### **3.1. Architectural Pattern Identification**
*   **Client-Side SPA:** The application is a Single-Page Application running entirely in the browser.
*   **Component-Based UI:** The interface is built with React.
*   **Lifted State:** All major application state is managed in the root `App.tsx` component.

#### **3.2. Code Quality & Concern Analysis**
**Positive Findings:**
*   **Good Separation of Concerns:** Logic (`services`), UI (`components`), types, and constants are well-separated.
*   **Strong Encapsulation of API Logic:** All prompt engineering is contained within `geminiService.ts`.

**Critical Code Smells:**
*   **Critical Concern: Component Monolith:** `App.tsx` remains the top refactoring priority. It is too large and handles too many responsibilities.
*   **Medium Concern: Manual DOM Manipulation:** The popover positioning logic in `App.tsx` is complex and a candidate for replacement with a more robust library-based solution.

#### **3.3. Backlog Generation**

*   **Technical Debt (High Priority):**
    *   **Refactor `App.tsx`:** Decompose the main component into smaller, focused custom hooks (`useCustomTags`, `useFileIO`, etc.).

*   **Refactoring Opportunities (Medium Priority):**
    *   **Introduce State Management Library:** Adopt a lightweight global state manager (e.g., `Zustand`) to decouple state and prevent prop drilling.
    *   **Abstract Prompt Construction:** Create a "Prompt Builder" utility within `geminiService.ts`.

*   **New Features (Future Evolution):**
    *   **Implement Streaming Responses:** Modify services and components to use `generateContentStream` for a better UX.
    *   **Add Comparative (Diff) View:** Create a component to display a side-by-side comparison of content changes.
    *   **Expand Profile Management:** Allow users to save and load multiple named "context profiles" in `localStorage`.

*   **Questions for Human Collaborators:**
    1.  What is the target production environment?
    2.  Is the current undo/redo history implementation performant enough for very large documents?

#### **3.4. Incremental Evolution Roadmap**

1.  **Phase 1: Foundational Refactoring (In Progress)**
    *   **Goal:** Address the most critical technical debt to improve maintainability.
    *   **Tasks:**
        1.  ✅ **DONE:** Integrate `pnpm` and `Vite` to establish a modern build process.
        2.  **NEXT:** Begin refactoring `App.tsx` by extracting the `useHistoryState` hook and other logic into their own custom hooks.

2.  **Phase 2: Core User Experience (Short Term)**
    *   **Goal:** Deliver high-impact improvements to the core user workflow.
    *   **Tasks:**
        1.  Implement streaming AI responses.
        2.  Create the side-by-side "diff" view.

3.  **Phase 3: Power Features & Scalability (Mid Term)**
    *   **Goal:** Enhance capabilities for advanced users and prepare for future complexity.
    *   **Tasks:**
        1.  Implement local "Profile Management".
        2.  Introduce a global state manager like `Zustand`.
